#!/usr/bin/env python3
"""
Dossier Question Extractor

Extracts intelligence questions from dossier sections to guide discovery.
These questions form a feedback loop where each discovery pass answers
questions generated by the previous dossier.

Questions are categorized by type:
- LEADERSHIP: Decision makers, org structure
- TECHNOLOGY: Tech stack, platforms
- PROCUREMENT_TIMING: When they buy, cycle
- BUDGET: Financial capacity
- DIGITAL_MATURITY: Digital sophistication
- PARTNERSHIPS: Vendor relationships
- CHALLENGES: Pain points, needs
- STRATEGY: Strategic direction
- COMPETITIVE: Market position
- GENERAL: Other questions
"""

import logging
import re
from datetime import datetime, timezone
from typing import Dict, List, Optional, Any
from dataclasses import dataclass

from schemas import DossierQuestion, DossierQuestionType, DossierQuestionStatus, DossierSection
from claude_client import ClaudeClient

logger = logging.getLogger(__name__)


class DossierQuestionExtractor:
    """
    Extract questions from dossier sections to guide discovery

    Uses pattern-based extraction + AI refinement to identify
    intelligence gaps that subsequent discovery passes should fill.
    """

    def __init__(self, claude_client: ClaudeClient):
        """
        Initialize question extractor

        Args:
            claude_client: Claude client for AI-powered extraction
        """
        self.claude_client = claude_client

        # Section-specific question templates
        self.section_question_templates = {
            "leadership": {
                "types": [DossierQuestionType.LEADERSHIP],
                "templates": [
                    "Who is the {role} at {entity}?",
                    "What is the decision-making structure for {domain}?",
                    "Who are the key stakeholders for {initiative_type}?",
                    "What is the leadership tenure and stability?",
                    "Who are the influencers vs decision makers?"
                ]
            },
            "digital_maturity": {
                "types": [DossierQuestionType.TECHNOLOGY, DossierQuestionType.DIGITAL_MATURITY],
                "templates": [
                    "What {platform_type} platforms are currently in use?",
                    "What is the technology adoption history?",
                    "What technology gaps or pain points exist?",
                    "How mature is the digital transformation?",
                    "What is the technical debt level?"
                ]
            },
            "ai_reasoner_assessment": {
                "types": [DossierQuestionType.TECHNOLOGY, DossierQuestionType.STRATEGY],
                "templates": [
                    "What AI/ML capabilities are currently in use?",
                    "What is the AI readiness assessment?",
                    "What data infrastructure supports AI initiatives?",
                    "What are the AI adoption barriers?"
                ]
            },
            "challenges_opportunities": {
                "types": [DossierQuestionType.CHALLENGES, DossierQuestionType.STRATEGY],
                "templates": [
                    "What are the primary challenges facing {entity}?",
                    "What initiatives are planned for {timeframe}?",
                    "What are the growth opportunities?",
                    "What constraints affect {domain} decisions?"
                ]
            },
            "strategic_analysis": {
                "types": [DossierQuestionType.STRATEGY, DossierQuestionType.COMPETITIVE],
                "templates": [
                    "What is the strategic direction for {domain}?",
                    "How does {entity} compare to competitors in {area}?",
                    "What partnerships are being pursued?",
                    "What is the market positioning strategy?"
                ]
            },
            "connections": {
                "types": [DossierQuestionType.PARTNERSHIPS],
                "templates": [
                    "Who are the key technology partners?",
                    "What vendor relationships exist?",
                    "What is the partnership ecosystem?",
                    "Who are the primary suppliers?"
                ]
            },
            "quick_actions": {
                "types": [DossierQuestionType.PROCUREMENT_TIMING, DossierQuestionType.BUDGET],
                "templates": [
                    "What is the procurement timeline?",
                    "When is the next procurement window?",
                    "What is the budget range for {category}?",
                    "What is the typical procurement cycle duration?"
                ]
            }
        }

        # Patterns for extracting questions from section content
        self.question_patterns = [
            r'\bWho\b.{0,100}\?',  # Who questions
            r'\bWhat\b.{0,100}\?',  # What questions
            r'\bWhen\b.{0,100}\?',  # When questions
            r'\bHow\b.{0,100}\?',   # How questions
            r'\bWhy\b.{0,100}\?',   # Why questions
            r'\bWhere\b.{0,100}\?', # Where questions
        ]

    async def extract_questions_from_section(
        self,
        section: DossierSection,
        entity_name: str,
        max_questions: int = 5
    ) -> List[DossierQuestion]:
        """
        Extract questions from a single dossier section

        Args:
            section: Dossier section to extract from
            entity_name: Entity name for context
            max_questions: Maximum questions to extract per section

        Returns:
            List of extracted DossierQuestion objects
        """
        questions = []

        # Get question types for this section
        section_template = self.section_question_templates.get(section.id, {})
        question_types = section_template.get("types", [DossierQuestionType.GENERAL])

        # Extract using patterns
        for pattern in self.question_patterns:
            matches = re.findall(pattern, ' '.join(section.content), re.IGNORECASE)
            for match in matches[:max_questions]:
                # Clean up the question
                question_text = match.strip()

                # Skip if too short
                if len(question_text) < 15:
                    continue

                # Determine question type from content
                question_type = self._classify_question_type(question_text, question_types)

                # Calculate priority based on keywords
                priority = self._calculate_priority(question_text, section.id)

                # Generate question ID
                question_id = f"q_{section.id}_{len(questions)}_{int(datetime.now(timezone.utc).timestamp())}"

                # Create question object
                question = DossierQuestion(
                    question_id=question_id,
                    section_id=section.id,
                    question_type=question_type,
                    question_text=question_text,
                    priority=priority,
                    confidence=0.0,
                    status=DossierQuestionStatus.PENDING,
                    search_strategy=self._generate_search_strategy(question_text, question_type, entity_name)
                )

                questions.append(question)

            # Stop if we've reached max questions
            if len(questions) >= max_questions:
                break

        # If we didn't find enough with patterns, use AI to generate questions
        if len(questions) < max_questions:
            ai_questions = await self._generate_ai_questions(
                section,
                entity_name,
                max_questions - len(questions),
                question_types
            )
            questions.extend(ai_questions)

        logger.info(f"Extracted {len(questions)} questions from section {section.id}")
        return questions

    async def extract_questions_from_dossier(
        self,
        sections: List[DossierSection],
        entity_name: str,
        max_per_section: int = 5
    ) -> List[DossierQuestion]:
        """
        Extract questions from all dossier sections

        Args:
            sections: All dossier sections
            entity_name: Entity name for context
            max_per_section: Max questions per section

        Returns:
            List of all extracted questions
        """
        all_questions = []

        for section in sections:
            questions = await self.extract_questions_from_section(
                section,
                entity_name,
                max_per_section
            )
            all_questions.extend(questions)

        logger.info(f"Extracted {len(all_questions)} total questions from {len(sections)} sections")
        return all_questions

    def _classify_question_type(
        self,
        question_text: str,
        section_types: List[DossierQuestionType]
    ) -> DossierQuestionType:
        """
        Classify question into type based on keywords

        Args:
            question_text: The question text
            section_types: Expected types from section template

        Returns:
            Classified question type
        """
        question_lower = question_text.lower()

        # Keyword mappings
        type_keywords = {
            DossierQuestionType.LEADERSHIP: ['leader', 'decision maker', 'manager', 'director', 'cto', 'cio', 'ceo'],
            DossierQuestionType.TECHNOLOGY: ['crm', 'platform', 'software', 'technology', 'system', 'tool', 'ai', 'ml'],
            DossierQuestionType.PROCUREMENT_TIMING: ['when', 'timeline', 'procurement', 'buy', 'purchase', 'window'],
            DossierQuestionType.BUDGET: ['budget', 'cost', 'price', 'spend', 'financial', 'revenue'],
            DossierQuestionType.DIGITAL_MATURITY: ['maturity', 'digital', 'transformation', 'adoption', 'sophisticated'],
            DossierQuestionType.PARTNERSHIPS: ['partner', 'vendor', 'supplier', 'relationship'],
            DossierQuestionType.CHALLENGES: ['challenge', 'problem', 'issue', 'pain', 'gap', 'barrier'],
            DossierQuestionType.STRATEGY: ['strategy', 'plan', 'initiative', 'roadmap', 'direction'],
            DossierQuestionType.COMPETITIVE: ['competitor', 'competitive', 'market', 'ranking']
        }

        # Check keywords
        for qtype, keywords in type_keywords.items():
            if any(keyword in question_lower for keyword in keywords):
                return qtype

        # Fallback to section types
        if section_types:
            return section_types[0]

        return DossierQuestionType.GENERAL

    def _calculate_priority(self, question_text: str, section_id: str) -> int:
        """
        Calculate question priority (1-10) based on keywords

        Args:
            question_text: The question text
            section_id: Section identifier

        Returns:
            Priority score 1-10
        """
        question_lower = question_text.lower()

        # High priority keywords (7-10)
        high_priority = ['decision maker', 'procurement', 'budget', 'timeline', 'crm', 'ai platform']
        if any(keyword in question_lower for keyword in high_priority):
            return min(10, 7 + question_lower.count('?'))

        # Medium priority (4-6)
        medium_priority = ['technology', 'digital', 'partnership', 'strategy', 'challenge']
        if any(keyword in question_lower for keyword in medium_priority):
            return 6

        # Low priority (1-3)
        return 3

    def _generate_search_strategy(
        self,
        question_text: str,
        question_type: DossierQuestionType,
        entity_name: str
    ) -> Dict[str, Any]:
        """
        Generate search strategy for answering this question

        Args:
            question_text: The question
            question_type: Type of question
            entity_name: Entity name

        Returns:
            Search strategy dictionary
        """
        strategy = {
            "primary_sources": [],
            "search_queries": [],
            "hop_types": []
        }

        question_lower = question_text.lower()

        # Leadership questions
        if question_type == DossierQuestionType.LEADERSHIP:
            strategy["primary_sources"] = ["official_site", "linkedin", "press_releases"]
            strategy["search_queries"] = [
                f'"{entity_name}" leadership team',
                f'"{entity_name}" decision maker technology',
                f'"{entity_name}" CTO CIO director'
            ]
            strategy["hop_types"] = ["official_site", "linkedin"]

        # Technology questions
        elif question_type == DossierQuestionType.TECHNOLOGY:
            strategy["primary_sources"] = ["official_site", "case_studies", "job_postings"]
            strategy["search_queries"] = [
                f'"{entity_name}" CRM platform',
                f'("{entity_name}" OR "{entity_name} club") analytics software',
                f'"{entity_name}" technology stack'
            ]
            strategy["hop_types"] = ["official_site", "job_boards", "case_studies"]

        # Procurement timing questions
        elif question_type == DossierQuestionType.PROCUREMENT_TIMING:
            strategy["primary_sources"] = ["tender_portals", "official_site", "press_releases"]
            strategy["search_queries"] = [
                f'"{entity_name}" procurement timeline',
                f'"{entity_name}" tender',
                f'"{entity_name}" RFP'
            ]
            strategy["hop_types"] = ["tender_portals", "official_site"]

        # Budget questions
        elif question_type == DossierQuestionType.BUDGET:
            strategy["primary_sources"] = ["annual_reports", "financial_statements", "press_releases"]
            strategy["search_queries"] = [
                f'"{entity_name}" annual report',
                f'"{entity_name}" revenue',
                f'"{entity_name}" financial results'
            ]
            strategy["hop_types"] = ["official_site", "financial_sources"]

        # Default strategy
        else:
            strategy["primary_sources"] = ["official_site", "news", "press_releases"]
            strategy["search_queries"] = [
                f'"{entity_name}" {question_text.replace("?", "")}'
            ]
            strategy["hop_types"] = ["official_site", "news"]

        return strategy

    async def _generate_ai_questions(
        self,
        section: DossierSection,
        entity_name: str,
        count: int,
        question_types: List[DossierQuestionType]
    ) -> List[DossierQuestion]:
        """
        Use AI to generate questions from section content

        Args:
            section: Dossier section
            entity_name: Entity name
            count: Number of questions to generate
            question_types: Expected question types

        Returns:
            List of AI-generated questions
        """
        try:
            # Build prompt
            section_content = '\n'.join(section.content[:500])  # Limit content for cost

            prompt = f"""Analyze this dossier section and generate {count} specific intelligence questions that need to be answered.

Entity: {entity_name}
Section: {section.title}

Content:
{section_content}

Generate {count} questions (one per line) that:
1. Are specific and actionable
2. Relate to {', '.join([qt.value for qt in question_types])}
3. Can be answered through web research
4. Would improve our understanding of this entity

Questions:"""

            # Call Claude (use Haiku for cost efficiency)
            response = await self.claude_client.query(
                prompt,
                model="haiku",
                max_tokens=500
            )

            # Parse response
            questions = []
            for i, line in enumerate(response.strip().split('\n')[:count]):
                question_text = line.strip()

                # Skip empty lines
                if not question_text or len(question_text) < 15:
                    continue

                # Skip lines that don't look like questions
                if not question_text.endswith('?'):
                    continue

                question_id = f"q_ai_{section.id}_{i}_{int(datetime.now(timezone.utc).timestamp())}"

                question = DossierQuestion(
                    question_id=question_id,
                    section_id=section.id,
                    question_type=question_types[0] if question_types else DossierQuestionType.GENERAL,
                    question_text=question_text,
                    priority=5,  # AI questions get medium priority
                    confidence=0.0,
                    status=DossierQuestionStatus.PENDING,
                    search_strategy=self._generate_search_strategy(
                        question_text,
                        question_types[0] if question_types else DossierQuestionType.GENERAL,
                        entity_name
                    )
                )

                questions.append(question)

            logger.info(f"AI-generated {len(questions)} questions for section {section.id}")
            return questions

        except Exception as e:
            logger.error(f"Failed to generate AI questions: {e}")
            return []

    def prioritize_questions(
        self,
        questions: List[DossierQuestion],
        max_count: int = 20
    ) -> List[DossierQuestion]:
        """
        Sort questions by priority and return top N

        Args:
            questions: All questions
            max_count: Maximum number to return

        Returns:
            Top N prioritized questions
        """
        # Sort by priority (descending), then by status (PENDING first)
        sorted_questions = sorted(
            questions,
            key=lambda q: (
                -q.priority,
                0 if q.status == DossierQuestionStatus.PENDING else 1
            )
        )

        return sorted_questions[:max_count]


# Example usage
if __name__ == "__main__":
    import asyncio
    from claude_client import ClaudeClient

    async def test_extractor():
        claude = ClaudeClient()
        extractor = DossierQuestionExtractor(claude)

        # Create a mock section
        section = DossierSection(
            id="leadership",
            title="Leadership Team",
            content=[
                "The leadership team at Arsenal FC includes key decision makers for technology procurement.",
                "Who is the primary decision maker for technology investments?",
                "What is the decision-making process for major purchases?",
                "The CTO and CIO jointly oversee digital transformation initiatives."
            ]
        )

        # Extract questions
        questions = await extractor.extract_questions_from_section(
            section,
            "Arsenal FC",
            max_questions=5
        )

        print(f"Extracted {len(questions)} questions:")
        for q in questions:
            print(f"  - [{q.question_type.value}] {q.question_text} (priority: {q.priority})")

    asyncio.run(test_extractor())
